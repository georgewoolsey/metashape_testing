# Field Validation{#field_valid}

This section combines the SfM-derived tree locations with stem-mapped tree locations from field sampling. 

[Tinkham and Swayze (2021; p.6)](https://scholar.google.com/scholar?oi=bibs&hl=en&cluster=11260597505702247290) describe a methodology for matching UAS *detected* trees with stem mapped trees identified via traditional field *survey* methods. Note, *detected* trees in the excerpt below references UAS detected trees while *survey* trees references field-based stem mapped trees:

*Each of the detected tree outputs was matched with survey tree locations through an iterative process. Iteratively, a detected tree was selected, and all survey trees within a 3 m radius and 10% height of the detected tree were identified. If a survey tree met both the location and height precision requirements, it was considered a true positive (TP) detection, and both the survey and detected trees were removed from further matching. However, if no match was made, the detected tree was considered a commission (Co) and removed from further matching. This process was repeated until all detected trees were classified as true positive or commission, with all unmatched survey trees classified as omission (Om). Overall tree detection performance was described using the F-score metric.*

The F-score incorporates true positive, commission, and omission rates to determine how well the UAS detected trees represent the field-based stem mapped trees. As a measure of predictive performance, the highest possible value of an F-score is 1.0, indicating perfect precision and recall, and the lowest possible value is 0, if either precision or recall are zero.

$$
\textrm{F-score} = 2 \times \frac{\bigl(\frac{TP}{TP+Om} \times \frac{TP}{TP+Co} \bigr)}{\bigl(\frac{TP}{TP+Om} + \frac{TP}{TP+Co} \bigr)}
$$

The process to match UAS detected trees to field stem mapped trees implemented here is slightly different than the process described above. To match the data parametrization from the UAS point cloud processing workflow, only stem-mapped trees above `r unique(ptcld_processing_data$sttng_minimum_tree_height_m)` m were considered for analysis. Each UAS detected tree was matched with stem-mapped tree locations that were within a 3 m radius and 2 m height of the UAS detected tree. The matched UAS and stem-mapped tree pairs were jointly compared (rather than iteratively) to select the pair that minimized the height difference for both the stem-mapped tree and the UAS detected tree to ensure that only one UAS detected tree was selected for each stem-mapped tree. If more than one UAS detected tree had the same height difference to a stem-mapped tree, the UAS detected tree spatially nearest to the stem-mapped tree was selected as the match. These UAS detected trees with a paired stem-mapped tree after this filtering process were considered true positive ($TP$) detections.

To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; $Co$) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius with a minimum DBH of 5 in (12.69 cm) as only trees above this size were sampled as part of the overstory survey. UAS detected trees within this radius with an [estimated DBH](#local_mod) over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions ($Co$). The 2023-06 BHEF field surveys used $\frac{1}{10}$ acre (404.686 m^2^) plots with a 37.24 ft (11.35 m) radius for overstory sampling and $\frac{1}{400}$ acre (10.117 m^2^) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. All unmatched stem-mapped survey trees were classified as omissions ($Om$).

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
# While trapped in the FVS meeting I was able to get the field stem maps organized and build stand boundary polygons for use in the validation of the software comparison project.
# 
# However, also realized I made a really dumb move. I discovered that I assigned the same imagery for SQ09_02 and SQ02_04, so all of the SQ02_04 data is trash. Deciding we will just move ahead with the five datasets I did not screw up.
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Setup

*We'll go through one example first and then we'll create the F-score for each test data set*

Update the `ptcld_processing_data` created in [this section](#ptcld_analysis)

```{r}
# list of study sites with completed uas data
study_site_list = ptcld_processing_data$study_site %>% unique() %>% toupper()

# list of field validation data
validation_data =
  list.files(
    "../data/field_validation"
    , pattern = "\\.gpkg$", full.names = T
  ) %>% 
  normalizePath() %>% 
  dplyr::as_tibble() %>% 
  dplyr::rename(validation_file_full_path=1) %>% 
  dplyr::mutate(
    study_site = validation_file_full_path %>% 
      toupper() %>% 
      stringr::str_extract(pattern = paste(study_site_list, collapse = "|"))
  ) %>% 
  dplyr::filter(study_site %in% study_site_list) %>% 
  dplyr::group_by(study_site) %>% 
  dplyr::filter(dplyr::row_number() == 1) %>% 
  dplyr::ungroup()

# what about the field plot boundary?
validation_plots = sf::st_read("../data/field_validation/Field_Data_Boundary.shp") %>% 
  dplyr::rename_with(tolower) %>% 
  dplyr::mutate(
    study_site = site %>% 
      toupper() %>% 
      stringr::str_extract(pattern = paste(study_site_list, collapse = "|"))
  ) %>% 
  dplyr::filter(study_site %in% study_site_list) %>% 
  dplyr::group_by(study_site) %>% 
  dplyr::filter(dplyr::row_number() == 1) %>% 
  dplyr::ungroup()

# where is the uas processed data?
ptcld_processing_data =
  ptcld_processing_data %>% 
  dplyr::mutate(
    processed_data_dir = dirname(tracking_file_full_path)
    , processing_id = dplyr::row_number()
  )
  
```

where are these validation plots and what do they look like?

```{r}
# what?
validation_plots %>% dplyr::glimpse()
# where?
mapview::mapviewOptions(basemaps = c("Stadia.StamenTonerLite","Esri.WorldImagery"))
validation_plots %>% 
  sf::st_buffer(2000) %>% # because they are small
  mapview::mapview(col.regions = "blue", layer.name = "plot", alpha.regions = 0.7)
```

## Load Example Data

field validation data

```{r}
# function to read field data once per site
read_field_data <- function(my_study_site) {
  d = sf::st_read(
    validation_data %>% 
      dplyr::filter(study_site == my_study_site) %>% 
      dplyr::pull(validation_file_full_path)
    ) %>% 
    dplyr::mutate(
      study_site = my_study_site
    ) %>% 
    dplyr::rename_with(tolower) %>% 
    dplyr::rename(
      field_dbh_cm = dbh_cm
      , field_tree_height_m = ht_m
    ) %>% 
    sf::st_set_geometry("geometry") %>% 
    dplyr::filter(
      !is.na(field_dbh_cm)
      & !is.na(field_tree_height_m)
      & sf::st_is_valid(geometry)
      # only keep trees that are above height threshold used for uas processing
      & field_tree_height_m >= min(ptcld_processing_data$sttng_minimum_tree_height_m)
      # & field_dbh_cm >= min_tree_dbh_cm # if know min field dbh for field sampling
    )
  # keep only trees within sampling plot
  d %>% 
    sf::st_intersection(
      validation_plots %>% 
        dplyr::filter(study_site == my_study_site) %>% 
        dplyr::mutate(intersected_with_plot_geom = T) %>% 
        dplyr::select(intersected_with_plot_geom) %>% 
        sf::st_transform(sf::st_crs(d))
    ) %>% 
    dplyr::mutate(
      field_tree_id = dplyr::row_number()
      , tree_utm_x = sf::st_coordinates(geometry)[,1] #lon
      , tree_utm_y = sf::st_coordinates(geometry)[,2] #lat
    ) %>% 
    dplyr::relocate(field_tree_id)
    
}
# read it
field_data = read_field_data(study_site_list[1])
# what is it?
field_data %>% dplyr::glimpse()
```

uas data

```{r}
# function to read uas data based on study site and row
read_uas_data = function(row_n, my_study_site, my_crs = sf::st_crs(field_data)) {
  # which data?
  dta = ptcld_processing_data %>% 
    dplyr::filter(
      study_site == my_study_site
    ) %>% 
    dplyr::filter(dplyr::row_number() == row_n)
  
  # where is this file?
  fnm = dta %>% 
    dplyr::mutate(
      fnm = paste0(
        processed_data_dir
        , "/"
        , file_name
        , "_final_detected_tree_tops.gpkg"
      )
    ) %>% 
    dplyr::pull(fnm)
  # read it
  sf::st_read(fnm) %>% 
    dplyr::mutate(
      study_site = dta$study_site[1]
      , file_name = dta$file_name[1]
      , software = dta$software[1]
    ) %>% 
    dplyr::rename_with(tolower) %>% 
    sf::st_set_geometry("geometry") %>% 
    sf::st_transform(my_crs)
}
# read it
uas_data = read_uas_data( 
  row_n = 1
  , my_study_site = study_site_list[1]
)
# what is it?
uas_data %>% dplyr::glimpse()
```

## UAS-Field Validation Data

### True Positive Identification

The UAS detected and stem-mapped tree pairs identified in this filtering process (detailed above) were considered true positive ($TP$) detections.

```{r, results='hide'}
## BUFFER THE UAS TREES AND SPATIALLY MATCH FIELD TREES BASED ON THAT BUFFER
true_positive_trees_fn = function(uas_data, field_data, max_dist_m = 3, max_height_error_m = 2){
  ## get FIELD trees within radius OF UAS TREES
    potential_tree_pairs_temp = uas_data %>% 
      dplyr::select(treeid, tree_height_m) %>% 
      # buffer point
      sf::st_buffer(max_dist_m) %>% 
      # spatial join with all FIELD tree points
      sf::st_join(
        field_data %>% 
          dplyr::select(
            field_tree_id, field_tree_height_m
            , tree_utm_x, tree_utm_y
          )
        , join = sf::st_intersects
        , left = F # performs inner join to only keep uas trees with a match
      ) %>% 
      # calculate height difference
      dplyr::mutate(
        height_diff_m = abs(tree_height_m-field_tree_height_m)
        , height_diff_pct = height_diff_m/field_tree_height_m
      ) %>% 
      # removes tree pairs that are outside of the allowable error
      # dplyr::filter(height_diff_pct <= max_height_error_pct) %>% 
      dplyr::filter(height_diff_m <= max_height_error_m) %>% 
      dplyr::select(-c(height_diff_m)) %>% 
      dplyr::relocate(treeid, field_tree_id)
  
  ## apply pair selection criteria if there are potential tree pairs
    if(nrow(potential_tree_pairs_temp)>0){
      ## calculate row by row distances and height differences
        potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
          # this is the position of the uas tree
          sf::st_centroid() %>% 
          sf::st_set_geometry("geom1") %>% 
          dplyr::bind_cols(
            potential_tree_pairs_temp %>% 
              sf::st_drop_geometry() %>% 
              dplyr::select("tree_utm_x", "tree_utm_y") %>% 
              # this is the position of the field tree
              sf::st_as_sf(
                coords = c("tree_utm_x", "tree_utm_y"), crs = sf::st_crs(uas_data)
              ) %>% 
              sf::st_set_geometry("geom2")
          ) %>% 
          dplyr::mutate(
            distance_m = sf::st_distance(geom1, geom2, by_element = T) %>% as.numeric()
          ) %>% 
          sf::st_drop_geometry() %>% 
          dplyr::select(-c(tree_utm_x, tree_utm_y, geom2))
      
      ## define function to select the best tree pair
        select_best_tree_pair_fn <- function(df) {
         df %>% 
          dplyr::group_by(field_tree_id) %>% 
          dplyr::arrange(field_tree_id, height_diff_pct, distance_m, desc(tree_height_m), treeid) %>% 
          dplyr::mutate(
            # at the field tree level...the number of uas trees
            n_uas_trees = dplyr::n()
            # at the field tree level...
              # the closest uas tree in height tie breaker distance, uas_tree_height_m, id
            , rank_within_field_tree = dplyr::row_number()
          ) %>% 
          dplyr::group_by(treeid) %>% 
          dplyr::arrange(treeid, height_diff_pct, distance_m, desc(field_tree_height_m), field_tree_id) %>% 
          dplyr::mutate(
            # at the uas tree level...the number of field trees
            n_field_trees = dplyr::n()
            # at the field tree level...
              # the closest field tree in height tie breaker distance, uas_tree_height_m, id
            , rank_within_uas_tree = dplyr::row_number()
          ) %>% 
          dplyr::ungroup() %>% 
          # select the uas-field tree pair with the minimum height difference
          dplyr::filter(
            rank_within_field_tree == 1
            & rank_within_uas_tree == 1
          ) %>% 
          # remove columns
          dplyr::select(
            -c(tidyselect::starts_with("rank_"), tidyselect::starts_with("n_"))
          )
        }
      
      ## first filter for tree pairs
        true_positive_trees = select_best_tree_pair_fn(potential_tree_pairs_temp)
      
      ##remove matches from potential tree pairs 
        potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
          dplyr::filter(
            !(treeid %in% true_positive_trees$treeid)
            & !(field_tree_id %in% true_positive_trees$field_tree_id)
          )
        
      ## keep filtering for best pair until no unique pairs remain
        while(nrow(potential_tree_pairs_temp)>0) {
          # keep filtering for best pair until no unique pairs remain
          true_positive_trees = true_positive_trees %>% 
            dplyr::bind_rows(
              select_best_tree_pair_fn(potential_tree_pairs_temp)
            )
          #remove matches from potential tree pairs 
          potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
            dplyr::filter(
              !(treeid %in% true_positive_trees$treeid)
              & !(field_tree_id %in% true_positive_trees$field_tree_id)
            )
        }
      ## rename columns and flag
        true_positive_trees = true_positive_trees %>% 
          dplyr::rename(
            uas_tree_height_m = tree_height_m
            , uas_tree_id = treeid
            , field_uas_distance_m = distance_m
          ) %>% 
          dplyr::mutate(
            field_uas_group = "true positive"
          ) 
    }else{ # if there are spatially matched trees
      true_positive_trees = dplyr::tibble(
        uas_tree_id = as.character(NA)
        , field_tree_id = as.character(NA)
        , uas_tree_height_m = as.numeric(NA)
        , field_tree_height_m = as.numeric(NA)
        , height_diff_pct = as.numeric(NA)
        , field_uas_distance_m = as.numeric(NA)
        , field_uas_group = as.character(NA)
      )
    }
  # return
    return(true_positive_trees)
}
```

True positive detections

```{r}
true_positive_trees = true_positive_trees_fn(uas_data, field_data)
# what?
true_positive_trees %>% dplyr::glimpse()
#check data
  true_positive_trees %>%
    dplyr::summarise(
      n_rows = n()
      , unique_uas_trees = n_distinct(uas_tree_id)
      , unique_field_trees = n_distinct(field_tree_id)
      , unique_pairs = n_distinct(field_tree_id, uas_tree_id)
    ) %>% 
    kableExtra::kbl(caption = "results of true positive stem-uas tree matching") %>% 
    kableExtra::kable_styling()
```

### Combine with Commission and Omission

To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; $Co$) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius of 11.35 m. UAS detected trees within this radius with an [estimated DBH](#local_mod) over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions ($Co$).

Omissions ($Om$) are stem-mapped trees without a UAS detected tree match.

```{r, results='hide'}
field_uas_comparison_fn = function(uas_data, field_data, true_positive_trees, plot_data){
  field_uas_comparison = dplyr::bind_rows(
    ## true positive
      true_positive_trees
    ## omission
      , field_data %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(
          field_tree_id, field_tree_height_m
        ) %>% 
        dplyr::anti_join(
          true_positive_trees
          , by = dplyr::join_by(field_tree_id)
        ) %>% 
        dplyr::mutate(
          field_uas_group = "omission"
        )
    ## commission
      , plot_data %>% 
        sf::st_transform(sf::st_crs(uas_data)) %>% 
        dplyr::select(study_site) %>% 
        # join with uas tree points
        sf::st_join(
          uas_data %>% 
            dplyr::filter(
              !treeid %in% true_positive_trees$uas_tree_id
            ) %>% 
            dplyr::select(treeid) %>% 
            dplyr::rename(uas_tree_id=treeid)
          , join = sf::st_intersects
          , left = F # performs inner join to only keep uas trees and plots with a match
        ) %>% 
        dplyr::select(-c(study_site)) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::mutate(
          field_uas_group = "commission"
        )
  ) %>% 
    # attach uas data
    dplyr::left_join(
      uas_data %>%
        sf::st_set_geometry("geometry") %>% 
        dplyr::mutate(
          uas_tree_utm_x = sf::st_coordinates(geometry)[,1] #lon
          , uas_tree_utm_y = sf::st_coordinates(geometry)[,2] #lat
        ) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(treeid, tree_height_m, dbh_cm, uas_tree_utm_x, uas_tree_utm_y) %>% 
        dplyr::rename(
          uas_tree_id = treeid
          , uas_tree_height_m = tree_height_m
          , uas_dbh_cm = dbh_cm
        )
      , by = dplyr::join_by(uas_tree_id)
    ) %>% 
    # attach field data
    dplyr::left_join(
      field_data %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(
          field_tree_id, field_tree_height_m, field_dbh_cm
          , tree_utm_x, tree_utm_y
        ) %>% 
        dplyr::rename(
          field_tree_utm_x = tree_utm_x
          , field_tree_utm_y = tree_utm_y
        )
      , by = dplyr::join_by(field_tree_id)
    ) %>% 
    # update data
    dplyr::mutate(
      uas_tree_height_m = uas_tree_height_m.y
      , field_tree_height_m = field_tree_height_m.y
      , field_uas_group = factor(
        field_uas_group
        , ordered = T
        , levels = c(
          "true positive"
          , "commission"
          , "omission"
        )
      ) %>% forcats::fct_rev()
      , dbh_diff_cm = uas_dbh_cm - field_dbh_cm
      , tree_height_diff_m = uas_tree_height_m - field_tree_height_m
      , dbh_diff_pct = dbh_diff_cm/field_dbh_cm
      , height_diff_pct = tree_height_diff_m/field_tree_height_m
      , abs_dbh_diff_pct = abs(dbh_diff_pct)
      , abs_height_diff_pct = abs(height_diff_pct)
      # attach identifying data
      , study_site = uas_data$study_site[1]
      , file_name = uas_data$file_name[1]
      , software = uas_data$software[1]
    ) %>% 
    dplyr::relocate(field_uas_group) %>% 
    dplyr::select(-c(tidyselect::ends_with(".x"), tidyselect::ends_with(".y")))
    # # convert to imperial units
    # calc_imperial_units_fn()
  # return
  return(field_uas_comparison)
}
```

return comparison data

```{r}
field_uas_comparison = field_uas_comparison_fn(
  uas_data
  , field_data
  , true_positive_trees
  , plot_data = 
      validation_plots %>% 
        dplyr::filter(study_site == study_site_list[1])
)
# what?
field_uas_comparison %>% dplyr::glimpse()
```

### Define function for all

```{r}
validation_fn <- function(study_site_nm) {
  # plot
  validation_plot = validation_plots %>% 
    dplyr::filter(study_site == study_site_list[1])
  # read field data
  field_data = read_field_data(study_site_nm)
  # function for a file name
  validate_file_fn = function(
    row, site = study_site_nm, fld = field_data, plt = validation_plot
  ){
    # uas_data
      uas_data = read_uas_data(
        row_n = row
        , my_study_site = site
        , my_crs = sf::st_crs(fld)
      )
    # true positives
      true_positive_trees = true_positive_trees_fn(uas_data, fld)
    # field uas comparison
      field_uas_comparison = field_uas_comparison_fn(
        uas_data
        , fld
        , true_positive_trees
        , plot_data = plt
      )
    # write
      write.csv(
        field_uas_comparison
        , paste0(
          ptcld_processing_data %>% 
            dplyr::filter(
              study_site == site
              & 
            ) %>% 
            dplyr::pull(processed_data_dir)
          , "_field_uas_comparison_data.csv"
        )
        , row.names = F
      )
  }
}


## write
write.csv(field_uas_comparison, paste0(delivery_dir,"/field_uas_comparison_data.csv"), row.names = F)

## aggregate data to plot level
field_uas_comparison_plot =
  field_uas_comparison %>% 
  dplyr::count(plot_id, plot_lab, field_uas_group) %>% 
  dplyr::group_by(plot_id, plot_lab) %>% 
  dplyr::mutate(
    pct = n/sum(n)
    , tot = sum(n)
    , tp_pct=max(ifelse(field_uas_group=="true positive",pct,0)) 
  ) %>% 
  dplyr::ungroup() %>% 
  # attach f score
  dplyr::inner_join(
    field_uas_comparison %>% 
      dplyr::count(plot_id, field_uas_group) %>% 
      dplyr::mutate(field_uas_group = dplyr::case_when(
        field_uas_group == "true positive" ~ "tp"
        , field_uas_group == "commission" ~ "co"
        , field_uas_group == "omission" ~ "om"
      )) %>% 
      tidyr::pivot_wider(
        names_from = field_uas_group
        , values_from = n
        , values_fill = 0
      ) %>% 
      dplyr::mutate(
        plot_f_score = dplyr::coalesce(
          2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) )
          , 0
        )
      ) %>% 
      dplyr::select(plot_id, plot_f_score)
    , by = dplyr::join_by(plot_id)
  )
```


### Example comparison data exploration

#### Height vs. DBH of $Tp$, $Co$, $Om$

```{r fld-dta-sum-htdbh}
field_uas_comparison %>% 
  dplyr::mutate(
    dbh_temp = dplyr::coalesce(field_dbh_cm, uas_dbh_cm)
    , ht_temp = dplyr::coalesce(field_tree_height_m, uas_tree_height_m)
  ) %>% 
  ggplot(
    mapping = aes(x = ht_temp, y = dbh_temp, color = field_uas_group)
  ) +
    geom_point(
      mapping = aes(shape = field_uas_group)
      , alpha=0.8
      , size=2
    ) +
    scale_color_viridis_d(option = "cividis") +
    scale_x_continuous(breaks = scales::extended_breaks(n=8)) +
    scale_y_continuous(breaks = scales::extended_breaks(n=8)) +
    labs(
      color = "detection"
      , shape = "detection"
      , y = "DBH (cm)"
      , x = "Tree Ht. (cm)"
      , title = "UAS and Stem-Mapped Tree Validation Summary"
      , subtitle = "height and DBH relationship"
    ) +
    theme_light() +
    theme(
      legend.position = "top"
      , legend.direction  = "horizontal"
      , legend.title = element_blank()
    ) +
    guides(
      color = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5))
      , shape = guide_legend(reverse = T)
    )  
```

#### Height and DBH Distribution $Tp$, $Co$, $Om$

```{r fld-dta-sum-htdbh-dist}
field_uas_comparison %>% 
  dplyr::mutate(
    dbh = dplyr::coalesce(field_dbh_cm, uas_dbh_cm)
    , height = dplyr::coalesce(field_tree_height_m, uas_tree_height_m)
  ) %>% 
  dplyr::select(dbh, height, field_uas_group) %>% 
  tidyr::pivot_longer(cols = -c(field_uas_group), names_to = "metric", values_to = "value") %>% 
  dplyr::group_by(field_uas_group,metric) %>% 
  dplyr::mutate(
    metric = dplyr::case_when(
      metric == "dbh" ~ "DBH (cm)"
      , metric == "height" ~ "Height (m)"
    )
    , n_rows = dplyr::n()
    , plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(n_rows,accuracy=1),")"
    )
  ) %>% 
  ggplot(mapping = aes(x = value, y = plot_lab, fill = field_uas_group)) +
    geom_violin() +
    geom_boxplot(width = 0.1, outlier.shape = NA, color = "gray66") +
    facet_grid(cols = vars(metric), scales = "free_x") +
    scale_fill_viridis_d(option = "cividis") +
    scale_x_continuous(breaks = scales::extended_breaks(n=8)) +
    labs(
      fill = ""
      , y = ""
      , x = ""
      , title = "UAS and Stem-Mapped Tree Validation Summary"
      , subtitle = "height and DBH distribution comparison"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
      , strip.text = element_text(color = "black", size = 12)
      , strip.background = element_rect(fill = "gray88")
    )
```

#### Detected Overstory ($TP$) Height Difference

Detected overstory tree ($TP$) height reliability.

```{r fld-dta-sum-ht}
field_uas_comparison %>%
  dplyr::filter(field_uas_group == "true positive") %>%
  dplyr::group_by(field_uas_group) %>% 
  dplyr::mutate(
    plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(dplyr::n(),accuracy=1),")"
    )
    , color_box = median(height_diff_pct, na.rm=T)<0
  ) %>% 
  ggplot(mapping = aes(x = height_diff_pct, y = plot_lab )) + # height_diff_pct
    geom_vline(xintercept = 0, color = "gray22") +
    geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) +
    scale_fill_manual(values = c("steelblue", "coral")) +
    geom_point(color = "black", shape = ".") +
    scale_x_continuous(
      labels = scales::percent_format()
      , breaks = scales::extended_breaks(n=8)
      , limits = c(
        -max(field_uas_comparison$abs_height_diff_pct, na.rm = T)
        , max(field_uas_comparison$abs_height_diff_pct, na.rm = T)
      )
    ) +
    labs(
      fill = ""
      , y = ""
      , x = "Percent Difference in Height"
      , title = "Detected Overstory Height Difference"
      , caption = "-values = UAS<field | +values = UAS>field"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
    )
```

#### Detected Overstory ($TP$) DBH Difference

Detected overstory tree ($TP$) DBH reliability.

```{r fld-dta-sum-dbh}
field_uas_comparison %>%
  dplyr::filter(field_uas_group == "true positive") %>%
  dplyr::group_by(field_uas_group) %>% 
  dplyr::mutate(
    plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(dplyr::n(),accuracy=1),")"
    )
    , color_box = median(dbh_diff_pct, na.rm=T)<0
  ) %>%  
  ggplot(mapping = aes(x = dbh_diff_pct, y = plot_lab)) + # dbh_diff_pct
    geom_vline(xintercept = 0, color = "gray22") +
    geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) +
    scale_fill_manual(values = c("steelblue", "coral")) +
    geom_point(color = "black", shape = ".") +
    scale_x_continuous(
      labels = scales::percent_format()
      , breaks = scales::extended_breaks(n=8)
      , limits = c(
        -2,2
        # -max(field_uas_comparison$abs_dbh_diff_pct, na.rm = T)
        # , max(field_uas_comparison$abs_dbh_diff_pct, na.rm = T)
      )
    ) +
    labs(
      fill = ""
      , y = ""
      , x = "Percent Difference in DBH"
      , title = "Detected Overstory DBH Difference"
      , caption = "-values = UAS<field | +values = UAS>field"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
    )

```

#### Detected Overstory ($TP$) Reliability

Overstory trees considered in this analysis had a tree height >= `r scales::comma(min_tree_height_m*3.28, accuracy = 0.1)` ft and a tree DBH >= `r scales::comma(min_tree_dbh_cm*0.394, accuracy = 0.1)` in.

```{r fld-dta-sum-rmse, results='asis'}
dbh_f_temp = field_uas_comparison %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(field_dbh_cm)
dbh_u_temp = field_uas_comparison %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(uas_dbh_cm)
ht_f_temp = field_uas_comparison %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(field_tree_height_m)
ht_u_temp = field_uas_comparison %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(uas_tree_height_m)

data.frame(
  mae_dbh = Metrics::mae(
    dbh_f_temp
    , dbh_u_temp
  )
  , mape_dbh = Metrics::mape(
    dbh_f_temp
    , dbh_u_temp
  )
  , rmse_dbh = Metrics::rmse(
    dbh_f_temp
    , dbh_u_temp
  )
    ## height
  , mae_height = Metrics::mae(
    ht_f_temp
    , ht_u_temp
  )
  , mape_height = Metrics::mape(
    ht_f_temp
    , ht_u_temp
  )
  , rmse_height = Metrics::rmse(
    ht_f_temp
    , ht_u_temp
  )
) %>% 
  tidyr::pivot_longer(dplyr::everything()) %>% 
  tidyr::separate_wider_delim(cols = name, delim = "_", names = c("error", "metric")) %>% 
  tidyr::pivot_wider(names_from = error, values_from = value) %>% 
  dplyr::mutate(
    metric = dplyr::case_when(
      metric == "dbh" ~ "DBH (cm)"
      , metric == "height" ~ "Height (m)"
    )
    , n = field_uas_comparison %>% dplyr::filter(field_uas_group=="true positive") %>% nrow()
  ) %>% 
    kableExtra::kbl(
      caption = "Detected overstory tree height and DBH prediction performance"
      , col.names = c(
        " "
        , "Mean Abs. Error"
        , "Mean Abs. Percent Error"
        , "Root Mean Squared Error"
        , "N"
      )
      , digits = 2
    ) %>% 
    kableExtra::kable_styling()

```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

