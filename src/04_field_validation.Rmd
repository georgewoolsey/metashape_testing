# Field Validation{#field_valid}

This section combines the SfM-derived tree locations with stem-mapped tree locations from field sampling. 

[Tinkham and Swayze (2021; p.6)](https://scholar.google.com/scholar?oi=bibs&hl=en&cluster=11260597505702247290) describe a methodology for matching UAS *detected* trees with stem mapped trees identified via traditional field *survey* methods. Note, *detected* trees in the excerpt below references UAS detected trees while *survey* trees references field-based stem mapped trees:

*Each of the detected tree outputs was matched with survey tree locations through an iterative process. Iteratively, a detected tree was selected, and all survey trees within a 3 m radius and 10% height of the detected tree were identified. If a survey tree met both the location and height precision requirements, it was considered a true positive (TP) detection, and both the survey and detected trees were removed from further matching. However, if no match was made, the detected tree was considered a commission (Co) and removed from further matching. This process was repeated until all detected trees were classified as true positive or commission, with all unmatched survey trees classified as omission (Om). Overall tree detection performance was described using the F-score metric.*

The F-score incorporates true positive, commission, and omission rates to determine how well the UAS detected trees represent the field-based stem mapped trees. As a measure of predictive performance, the highest possible value of an F-score is 1.0, indicating perfect precision and recall, and the lowest possible value is 0, if either precision or recall are zero.

$$
\textrm{F-score} = 2 \times \frac{\bigl(\frac{TP}{TP+Om} \times \frac{TP}{TP+Co} \bigr)}{\bigl(\frac{TP}{TP+Om} + \frac{TP}{TP+Co} \bigr)}
$$

The process to match UAS detected trees to field stem mapped trees implemented here is slightly different than the process described above. To match the data parametrization from the UAS point cloud processing workflow, only stem-mapped trees above `r unique(ptcld_processing_data$sttng_minimum_tree_height_m)` m were considered for analysis. Each UAS detected tree was matched with stem-mapped tree locations that were within a 3 m radius and 2 m height of the UAS detected tree. The matched UAS and stem-mapped tree pairs were jointly compared (rather than iteratively) to select the pair that minimized the height difference for both the stem-mapped tree and the UAS detected tree to ensure that only one UAS detected tree was selected for each stem-mapped tree. If more than one UAS detected tree had the same height difference to a stem-mapped tree, the UAS detected tree spatially nearest to the stem-mapped tree was selected as the match. These UAS detected trees with a paired stem-mapped tree after this filtering process were considered true positive ($TP$) detections.

To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; $Co$) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius with a minimum DBH of 5 in (12.69 cm) as only trees above this size were sampled as part of the overstory survey. UAS detected trees within this radius with an [estimated DBH](#local_mod) over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions ($Co$). The 2023-06 BHEF field surveys used $\frac{1}{10}$ acre (404.686 m^2^) plots with a 37.24 ft (11.35 m) radius for overstory sampling and $\frac{1}{400}$ acre (10.117 m^2^) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. All unmatched stem-mapped survey trees were classified as omissions ($Om$).

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
# While trapped in the FVS meeting I was able to get the field stem maps organized and build stand boundary polygons for use in the validation of the software comparison project.
# 
# However, also realized I made a really dumb move. I discovered that I assigned the same imagery for SQ09_02 and SQ02_04, so all of the SQ02_04 data is trash. Deciding we will just move ahead with the five datasets I did not screw up.
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Setup

Update the `ptcld_processing_data` created in [this section](#ptcld_analysis)

```{r, include=FALSE, eval=F}
## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! for testing
list.files("../data", pattern = ".*_field_uas_comparison_data\\.csv$", full.names = T, recursive = T) %>% 
  purrr::map(file.remove)
# testing
ptcld_processing_data = ptcld_processing_data %>% 
  dplyr::slice_sample(n = 3, replace = F)
```

```{r}
# list of study sites with completed uas data
study_site_list = ptcld_processing_data$study_site %>% unique() %>% toupper()

# list of field validation data
validation_data =
  list.files(
    "../data/field_validation"
    , pattern = "\\.gpkg$", full.names = T
  ) %>% 
  normalizePath() %>% 
  dplyr::as_tibble() %>% 
  dplyr::rename(validation_file_full_path=1) %>% 
  dplyr::mutate(
    study_site = validation_file_full_path %>% 
      toupper() %>% 
      stringr::str_extract(pattern = paste(study_site_list, collapse = "|"))
  ) %>% 
  dplyr::filter(study_site %in% study_site_list) %>% 
  dplyr::group_by(study_site) %>% 
  dplyr::filter(dplyr::row_number() == 1) %>% 
  dplyr::ungroup()

# what about the field plot boundary?
validation_plots = sf::st_read("../data/field_validation/Field_Data_Boundary.shp") %>% 
  dplyr::rename_with(tolower) %>% 
  dplyr::mutate(
    study_site = site %>% 
      toupper() %>% 
      stringr::str_extract(pattern = paste(study_site_list, collapse = "|"))
  ) %>% 
  dplyr::filter(study_site %in% study_site_list) %>% 
  dplyr::group_by(study_site) %>% 
  dplyr::filter(dplyr::row_number() == 1) %>% 
  dplyr::ungroup()

# where is the uas processed data?
ptcld_processing_data =
  ptcld_processing_data %>% 
  dplyr::mutate(
    processed_data_dir = dirname(tracking_file_full_path)
    , processing_id = dplyr::row_number()
  )
```

where are these validation plots and what do they look like?

```{r}
# what?
validation_plots %>% dplyr::glimpse()
# where?
mapview::mapviewOptions(basemaps = c("OpenStreetMap","Esri.WorldImagery"))
validation_plots %>% 
  sf::st_buffer(2000) %>% # because they are small
  mapview::mapview(col.regions = "blue", layer.name = "plot", alpha.regions = 0.7)
```

## Data Load Functions

field validation data

```{r}
# function to read field data once per site
read_field_data <- function(my_study_site) {
  d = sf::st_read(
    validation_data %>% 
      dplyr::filter(study_site == my_study_site) %>% 
      dplyr::pull(validation_file_full_path)
    ) %>% 
    dplyr::mutate(
      study_site = my_study_site
    ) %>% 
    dplyr::rename_with(tolower) %>% 
    dplyr::rename(
      field_dbh_cm = dbh_cm
      , field_tree_height_m = ht_m
    ) %>% 
    sf::st_set_geometry("geometry") %>% 
    dplyr::filter(
      !is.na(field_dbh_cm)
      & !is.na(field_tree_height_m)
      & sf::st_is_valid(geometry)
      # only keep trees that are above height threshold used for uas processing
      & field_tree_height_m >= min(ptcld_processing_data$sttng_minimum_tree_height_m)
      # & field_dbh_cm >= min_tree_dbh_cm # if know min field dbh for field sampling
    )
  # keep only trees within sampling plot
  d %>% 
    sf::st_intersection(
      validation_plots %>% 
        dplyr::filter(study_site == my_study_site) %>% 
        dplyr::mutate(intersected_with_plot_geom = T) %>% 
        dplyr::select(intersected_with_plot_geom) %>% 
        sf::st_transform(sf::st_crs(d))
    ) %>% 
    dplyr::mutate(
      field_tree_id = dplyr::row_number()
      , tree_utm_x = sf::st_coordinates(geometry)[,1] #lon
      , tree_utm_y = sf::st_coordinates(geometry)[,2] #lat
    ) %>% 
    dplyr::relocate(field_tree_id)
    
}
```

uas data

```{r}
# function finds uas tree list
# reads it
# estimates linear model if not already used for DBH
read_uas_data = function(my_processing_id, my_crs = NULL) {
  # where is this file?
  fnm = ptcld_processing_data %>% 
    dplyr::filter(
      processing_id == my_processing_id
    ) %>% 
    dplyr::mutate(
      fnm = paste0(
        processed_data_dir
        , "/"
        , file_name
        , "_final_detected_tree_tops.gpkg"
      )
    ) %>% 
    dplyr::pull(fnm)
  
  if(file.exists(fnm)){
    # read it
    dta = sf::st_read(fnm) %>% 
      dplyr::mutate(
        processing_id = my_processing_id
      ) %>% 
      dplyr::rename_with(tolower) %>% 
      sf::st_set_geometry("geometry")
    
    # transform
    if(is.null(my_crs)){
      tcrs = sf::st_crs(dta)
    }else{tcrs = my_crs}
    
    dta = dta %>% 
      sf::st_transform(tcrs)
    
    #################
    # estimate linear model if not already used for DBH
    #################
    if(
      # is there sufficient training data?
      dta %>% 
        dplyr::filter(is_training_data == T) %>% 
        nrow() > 10 & 
      # was rf model used?
      ptcld_processing_data %>% 
        dplyr::filter(processing_id == my_processing_id) %>% 
        dplyr::pull(sttng_local_dbh_model) %>% 
        tolower() == "rf"
    ){
        # Gamma distribution for strictly positive response variable dbh
        stem_prediction_model = brms::brm(
          formula = dbh_cm ~ 1 + tree_height_m
          , data = dta %>%
              dplyr::filter(is_training_data==T) %>% 
              dplyr::select(dbh_cm, tree_height_m)
          , family = brms::brmsfamily("Gamma", link = "log")
          , prior = c(prior(gamma(0.01, 0.01), class = shape))
          , iter = 4000, warmup = 2000, chains = 4
          , cores = lasR::half_cores()
          , file = ptcld_processing_data %>%
              dplyr::filter(processing_id == my_processing_id) %>%
              dplyr::mutate(
                fff = paste0(
                  processed_data_dir
                  , "/"
                  , file_name
                  , "_local_dbh_height_model"
                )
              ) %>%
              dplyr::pull(fff)
          # , file_refit = "on_change"
        )
      #################
      # prediction data
      #################
        pred_temp = predict(stem_prediction_model, dta) %>% 
          dplyr::as_tibble() %>% 
          dplyr::pull(1)
        
        # add to data
        dta = dta %>% 
          dplyr::mutate(
            rf_dbh_cm = dbh_cm
            , pred_dbh_cm = pred_temp
            , lin_dbh_cm = ifelse(is_training_data==T, dbh_cm, pred_dbh_cm)
          ) %>% 
          dplyr::select(-c(pred_dbh_cm)) %>% 
          # pick a dbh to use
          dplyr::mutate(
            dbh_cm = lin_dbh_cm
            , dbh_m = dbh_cm/100
            , radius_m = dbh_m/2
            , basal_area_m2 = pi * (radius_m)^2
            , basal_area_ft2 = basal_area_m2 * 10.764
          )
    }else if(# is there sufficient training data?
      dta %>% 
        dplyr::filter(is_training_data == T) %>% 
        nrow() <= 10
    ){
      # the regional model was used which would result in the same est for rf and lin
      dta = dta %>% 
        dplyr::mutate(
          rf_dbh_cm = dbh_cm
          , lin_dbh_cm = dbh_cm
        )
    }else{
      # linear model was already used and no rf pred
      # could update this to estimate rf model if missing...#nextyear
      dta = dta %>% 
        dplyr::mutate(
          rf_dbh_cm = as.numeric(NA)
          , lin_dbh_cm = dbh_cm
        )
    }
    return(dta)
  }else{stop("could not find file: ", fnm)}
}
```

```{r, include=FALSE, eval=FALSE}
dta = read_uas_data(1)
dta %>% 
  ggplot(aes(x = tree_height_m, y = lin_dbh_cm, color = is_training_data)) + 
    geom_point(aes(y = reg_est_dbh_cm,color = "zz regional_est")) +
    geom_point(aes(y = rf_dbh_cm,color = "zz rf est")) +
    geom_point() + 
    labs(color = "lm est + training", x = "ht m", y = "dbh cm") +
    scale_color_viridis_d(option = "turbo") +
    scale_x_continuous(breaks = scales::extended_breaks(18)) +
    scale_y_continuous(breaks = scales::extended_breaks(16)) +
    theme_light() +
    theme(legend.position = "top") +
    guides(
      color = guide_legend(override.aes = list(size = 5))
    )
```


## Validation Data Functions

### True Positive Identification

The UAS detected and stem-mapped tree pairs identified in this filtering process (detailed above) were considered true positive ($TP$) detections.

```{r, results='hide'}
## BUFFER THE UAS TREES AND SPATIALLY MATCH FIELD TREES BASED ON THAT BUFFER
true_positive_trees_fn = function(uas_data, field_data, max_dist_m = 3, max_height_error_m = 2){
  ## get FIELD trees within radius OF UAS TREES
    potential_tree_pairs_temp = uas_data %>% 
      dplyr::select(treeid, tree_height_m) %>% 
      # buffer point
      sf::st_buffer(max_dist_m) %>% 
      # spatial join with all FIELD tree points
      sf::st_join(
        field_data %>% 
          dplyr::select(
            field_tree_id, field_tree_height_m
            , tree_utm_x, tree_utm_y
          )
        , join = sf::st_intersects
        , left = F # performs inner join to only keep uas trees with a match
      ) %>% 
      # calculate height difference
      dplyr::mutate(
        height_diff_m = abs(tree_height_m-field_tree_height_m)
        , height_diff_pct = height_diff_m/field_tree_height_m
      ) %>% 
      # removes tree pairs that are outside of the allowable error
      # dplyr::filter(height_diff_pct <= max_height_error_pct) %>% 
      dplyr::filter(height_diff_m <= max_height_error_m) %>% 
      dplyr::select(-c(height_diff_m)) %>% 
      dplyr::relocate(treeid, field_tree_id)
  
  ## apply pair selection criteria if there are potential tree pairs
    if(nrow(potential_tree_pairs_temp)>0){
      ## calculate row by row distances and height differences
        potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
          # this is the position of the uas tree
          sf::st_centroid() %>% 
          sf::st_set_geometry("geom1") %>% 
          dplyr::bind_cols(
            potential_tree_pairs_temp %>% 
              sf::st_drop_geometry() %>% 
              dplyr::select("tree_utm_x", "tree_utm_y") %>% 
              # this is the position of the field tree
              sf::st_as_sf(
                coords = c("tree_utm_x", "tree_utm_y"), crs = sf::st_crs(uas_data)
              ) %>% 
              sf::st_set_geometry("geom2")
          ) %>% 
          dplyr::mutate(
            distance_m = sf::st_distance(geom1, geom2, by_element = T) %>% as.numeric()
          ) %>% 
          sf::st_drop_geometry() %>% 
          dplyr::select(-c(tree_utm_x, tree_utm_y, geom2))
      
      ## define function to select the best tree pair
        select_best_tree_pair_fn <- function(df) {
         df %>% 
          dplyr::group_by(field_tree_id) %>% 
          dplyr::arrange(field_tree_id, height_diff_pct, distance_m, desc(tree_height_m), treeid) %>% 
          dplyr::mutate(
            # at the field tree level...the number of uas trees
            n_uas_trees = dplyr::n()
            # at the field tree level...
              # the closest uas tree in height tie breaker distance, uas_tree_height_m, id
            , rank_within_field_tree = dplyr::row_number()
          ) %>% 
          dplyr::group_by(treeid) %>% 
          dplyr::arrange(treeid, height_diff_pct, distance_m, desc(field_tree_height_m), field_tree_id) %>% 
          dplyr::mutate(
            # at the uas tree level...the number of field trees
            n_field_trees = dplyr::n()
            # at the field tree level...
              # the closest field tree in height tie breaker distance, uas_tree_height_m, id
            , rank_within_uas_tree = dplyr::row_number()
          ) %>% 
          dplyr::ungroup() %>% 
          # select the uas-field tree pair with the minimum height difference
          dplyr::filter(
            rank_within_field_tree == 1
            & rank_within_uas_tree == 1
          ) %>% 
          # remove columns
          dplyr::select(
            -c(tidyselect::starts_with("rank_"), tidyselect::starts_with("n_"))
          )
        }
      
      ## first filter for tree pairs
        true_positive_trees = select_best_tree_pair_fn(potential_tree_pairs_temp)
      
      ##remove matches from potential tree pairs 
        potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
          dplyr::filter(
            !(treeid %in% true_positive_trees$treeid)
            & !(field_tree_id %in% true_positive_trees$field_tree_id)
          )
        
      ## keep filtering for best pair until no unique pairs remain
        while(nrow(potential_tree_pairs_temp)>0) {
          # keep filtering for best pair until no unique pairs remain
          true_positive_trees = true_positive_trees %>% 
            dplyr::bind_rows(
              select_best_tree_pair_fn(potential_tree_pairs_temp)
            )
          #remove matches from potential tree pairs 
          potential_tree_pairs_temp = potential_tree_pairs_temp %>% 
            dplyr::filter(
              !(treeid %in% true_positive_trees$treeid)
              & !(field_tree_id %in% true_positive_trees$field_tree_id)
            )
        }
      ## rename columns and flag
        true_positive_trees = true_positive_trees %>% 
          dplyr::rename(
            uas_tree_height_m = tree_height_m
            , uas_tree_id = treeid
            , field_uas_distance_m = distance_m
          ) %>% 
          dplyr::mutate(
            field_uas_group = "true positive"
          ) 
    }else{ # if there are spatially matched trees
      true_positive_trees = dplyr::tibble(
        uas_tree_id = as.character(NA)
        , field_tree_id = as.character(NA)
        , uas_tree_height_m = as.numeric(NA)
        , field_tree_height_m = as.numeric(NA)
        , height_diff_pct = as.numeric(NA)
        , field_uas_distance_m = as.numeric(NA)
        , field_uas_group = as.character(NA)
      )
    }
  # return
    return(true_positive_trees)
}
```

### Combine with Commission and Omission

To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; $Co$) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius of 11.35 m. UAS detected trees within this radius with an [estimated DBH](#local_mod) over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions ($Co$).

Omissions ($Om$) are stem-mapped trees without a UAS detected tree match.

```{r, results='hide'}
field_uas_comparison_fn = function(uas_data, field_data, true_positive_trees, plot_data, overstory_ht_m = 7){
  field_uas_comparison = dplyr::bind_rows(
    ## true positive
      true_positive_trees %>% 
         dplyr::mutate(field_tree_id = as.numeric(field_tree_id))
    ## omission
      , field_data %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(
          field_tree_id, field_tree_height_m
        ) %>% 
        dplyr::anti_join(
          true_positive_trees %>% 
            dplyr::mutate(field_tree_id = as.numeric(field_tree_id))
          , by = dplyr::join_by(field_tree_id)
        ) %>% 
        dplyr::mutate(
          field_uas_group = "omission"
        )
    ## commission
      , plot_data %>% 
        sf::st_transform(sf::st_crs(uas_data)) %>% 
        dplyr::select(study_site) %>% 
        # join with uas tree points
        sf::st_join(
          uas_data %>% 
            dplyr::filter(
              !treeid %in% true_positive_trees$uas_tree_id
            ) %>% 
            dplyr::select(treeid) %>% 
            dplyr::rename(uas_tree_id=treeid)
          , join = sf::st_intersects
          , left = F # performs inner join to only keep uas trees and plots with a match
        ) %>% 
        dplyr::select(-c(study_site)) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::mutate(
          field_uas_group = "commission"
        )
  ) %>% 
  dplyr::filter(!is.na(field_uas_group) & field_uas_group!="") %>% 
    # attach uas data
    dplyr::left_join(
      uas_data %>%
        sf::st_set_geometry("geometry") %>% 
        dplyr::mutate(
          uas_tree_utm_x = sf::st_coordinates(geometry)[,1] #lon
          , uas_tree_utm_y = sf::st_coordinates(geometry)[,2] #lat
        ) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(treeid, tree_height_m, dbh_cm, uas_tree_utm_x, uas_tree_utm_y) %>% 
        dplyr::rename(
          uas_tree_id = treeid
          , uas_tree_height_m = tree_height_m
          , uas_dbh_cm = dbh_cm
        )
      , by = dplyr::join_by(uas_tree_id)
    ) %>% 
    # attach field data
    dplyr::left_join(
      field_data %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(
          field_tree_id, field_tree_height_m, field_dbh_cm
          , tree_utm_x, tree_utm_y
        ) %>% 
        dplyr::rename(
          field_tree_utm_x = tree_utm_x
          , field_tree_utm_y = tree_utm_y
        )
      , by = dplyr::join_by(field_tree_id)
    ) %>% 
    # update data
    dplyr::mutate(
      uas_tree_height_m = uas_tree_height_m.y
      , field_tree_height_m = field_tree_height_m.y
      , field_uas_group = factor(
        field_uas_group
        , ordered = T
        , levels = c(
          "true positive"
          , "commission"
          , "omission"
        )
      ) %>% forcats::fct_rev()
      , dbh_diff_cm = uas_dbh_cm - field_dbh_cm
      , tree_height_diff_m = uas_tree_height_m - field_tree_height_m
      , dbh_diff_pct = dbh_diff_cm/field_dbh_cm
      , height_diff_pct = tree_height_diff_m/field_tree_height_m
      , abs_dbh_diff_pct = abs(dbh_diff_pct)
      , abs_height_diff_pct = abs(height_diff_pct)
      # determine overstory/understory
      , overstory_understory_grp = dplyr::case_when(
        dplyr::coalesce(field_tree_height_m, uas_tree_height_m) >= overstory_ht_m ~ "overstory"
        , dplyr::coalesce(field_tree_height_m, uas_tree_height_m) < overstory_ht_m ~ "understory"
        , T ~ "error"
      ) %>% factor()
      # attach identifying data
      , study_site = uas_data$study_site[1]
      , file_name = uas_data$file_name[1]
      , software = uas_data$software[1]
      , overstory_ht_m = overstory_ht_m
    ) %>% 
    dplyr::relocate(field_uas_group) %>% 
    dplyr::select(-c(tidyselect::ends_with(".x"), tidyselect::ends_with(".y")))
    # # convert to imperial units
    # calc_imperial_units_fn()
  # return
  return(field_uas_comparison)
}
```

### Full validation function

function to write comparison data and return aggregate metrics when passed a `ptcld_processing_data$processing_id`

function returns:

1) write full validation tree list to disk
2) update ptcld_processing_data with metrics for testing:
  * f-score
  * height comparison metrics (mae, mape, smape, mse, rmse)
  * dbh comparison metrics (mae, mape, smape, mse, rmse)
  * path to full validation tree list written to disk

```{r}
#####################################################
# function to map over each file for a particular study site
#####################################################
  # function for a file name identified by processing_id in ptcld_processing_data
  validate_file_fn = function(p_id, fld_dta, plt_dta){
    # tree list file name
      tl_fnm = paste0(
          ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(processed_data_dir)
          , "/"
          , ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(file_name)
          , "_field_uas_comparison_data.csv"
        )
    # brms model
      brms_fnm = paste0(
          ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(processed_data_dir)
          , "/"
          , ptcld_processing_data %>% 
            dplyr::filter(processing_id == p_id) %>% 
            dplyr::pull(file_name)
          , "_local_dbh_height_model.rds"
        )
    # check it
    if(file.exists(tl_fnm) & file.exists(brms_fnm)){
      # read it
      field_uas_comparison = readr::read_csv(tl_fnm)
    }else{
      # uas_data
        u_dta = read_uas_data(
          my_processing_id = p_id
          , my_crs = sf::st_crs(fld_dta)
        )
      # true positives
        tp_trees = true_positive_trees_fn(uas_data = u_dta, field_data = fld_dta)
      # field uas comparison
        field_uas_comparison = field_uas_comparison_fn(
            uas_data = u_dta
            , field_data = fld_dta
            , true_positive_trees = tp_trees
            , plot_data = plt_dta
          ) %>% 
          # attach id information
          dplyr::bind_cols(
            ptcld_processing_data %>% 
              dplyr::filter(processing_id == p_id) %>% 
              dplyr::select(
                processing_id, study_site, file_name, software
                , depth_maps_generation_quality
                , depth_maps_generation_filtering_mode
                , processing_attribute3
                , processed_data_dir
              )
          )
        # write it
        write.csv(
          field_uas_comparison
          , tl_fnm
          , row.names = F
        )
    }
    ############################################
    # aggregate field_uas_comparison for return
    ############################################
      return_dta =
        ptcld_processing_data %>% 
        dplyr::filter(processing_id == p_id) %>%
        ############################################
        # overall statistics
        ############################################
        # attach f score
        dplyr::bind_cols(
          # blank data in case missing
          dplyr::tibble(field_uas_group = c("tp", "co", "om")) %>% 
          dplyr::left_join(
            field_uas_comparison %>% 
              dplyr::count(field_uas_group) %>% 
              dplyr::mutate(field_uas_group = dplyr::case_when(
                field_uas_group == "true positive" ~ "tp"
                , field_uas_group == "commission" ~ "co"
                , field_uas_group == "omission" ~ "om"
              ))
            , by = dplyr::join_by(field_uas_group)
          ) %>% 
          dplyr::mutate(n = ifelse(is.na(n),0,n)) %>% 
            tidyr::pivot_wider(
              names_from = field_uas_group
              , values_from = n
              , values_fill = 0
            ) %>% 
            dplyr::mutate(
              f_score = dplyr::coalesce(
                2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) )
                , 0
              )
            ) %>% 
            dplyr::rename(
              true_positive_n_trees = tp
              , commission_n_trees = co
              , omission_n_trees = om
            ) %>% 
            dplyr::ungroup()
        ) %>% 
        # attach summary error metrics
        dplyr::bind_cols(
          field_uas_comparison %>% 
            dplyr::filter(field_uas_group=="true positive") %>% 
            dplyr::ungroup() %>% 
            # thx Metrics pkg!!
            dplyr::summarise(
              # tree_height_m
              tree_height_m_mae = Metrics::mae(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_mape = Metrics::mape(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_smape = Metrics::smape(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_mse = Metrics::mse(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_rmse = Metrics::rmse(field_tree_height_m, uas_tree_height_m)
              # dbh_cm
              , dbh_cm_mae = Metrics::mae(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_mape = Metrics::mape(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_smape = Metrics::smape(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_mse = Metrics::mse(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_rmse = Metrics::rmse(field_dbh_cm, uas_dbh_cm)
            )
        ) %>% 
        ############################################
        # overstory/understory statistics
        ############################################
        # attach f score
        dplyr::bind_cols(
          # blank data in case missing
          tidyr::crossing(
            field_uas_group = c("tp", "co", "om")
            , overstory_understory_grp = c("overstory", "understory")
          ) %>% 
          dplyr::left_join(
            field_uas_comparison %>% 
              dplyr::count(field_uas_group, overstory_understory_grp) %>% 
              dplyr::mutate(field_uas_group = dplyr::case_when(
                field_uas_group == "true positive" ~ "tp"
                , field_uas_group == "commission" ~ "co"
                , field_uas_group == "omission" ~ "om"
              ))
            , by = dplyr::join_by(field_uas_group, overstory_understory_grp)
          ) %>% 
          dplyr::mutate(n = ifelse(is.na(n),0,n)) %>% 
            tidyr::pivot_wider(
              names_from = field_uas_group
              , values_from = n
              , values_fill = 0
            ) %>% 
            dplyr::mutate(
              f_score = dplyr::coalesce(
                2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) )
                , 0
              )
            ) %>% 
            dplyr::rename(
              true_positive_n_trees = tp
              , commission_n_trees = co
              , omission_n_trees = om
            ) %>% 
            dplyr::ungroup() %>% 
            tidyr::pivot_wider(
              names_from = overstory_understory_grp
              , values_from = -c(overstory_understory_grp)
              , values_fill = 0
              , names_glue = "{overstory_understory_grp}_{.value}"
            )
        ) %>% 
        # attach summary error metrics
        dplyr::bind_cols(
          field_uas_comparison %>% 
            dplyr::filter(field_uas_group=="true positive") %>% 
            dplyr::group_by(overstory_understory_grp) %>% 
            # thx Metrics pkg!!
            dplyr::summarise(
              # tree_height_m
              tree_height_m_mae = Metrics::mae(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_mape = Metrics::mape(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_smape = Metrics::smape(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_mse = Metrics::mse(field_tree_height_m, uas_tree_height_m)
              , tree_height_m_rmse = Metrics::rmse(field_tree_height_m, uas_tree_height_m)
              # dbh_cm
              , dbh_cm_mae = Metrics::mae(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_mape = Metrics::mape(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_smape = Metrics::smape(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_mse = Metrics::mse(field_dbh_cm, uas_dbh_cm)
              , dbh_cm_rmse = Metrics::rmse(field_dbh_cm, uas_dbh_cm)
            ) %>% 
            dplyr::ungroup() %>% 
            tidyr::pivot_wider(
              names_from = overstory_understory_grp
              , values_from = -c(overstory_understory_grp)
              , values_fill = 0
              , names_glue = "{overstory_understory_grp}_{.value}"
            )
        ) %>% 
        # where is the tree list ?
        dplyr::mutate(
          validation_file_full_path = tl_fnm
          # what is this overstory/understory?
          , overstory_ht_m = field_uas_comparison$overstory_ht_m[1]
        )
      
    # return
      return(return_dta)
  }
```

check validation function

```{r, results='hide'}
validation_temp = 
  validate_file_fn(
    p_id = ptcld_processing_data %>% 
      dplyr::filter(study_site == study_site_list[1]) %>% 
      dplyr::pull(processing_id) %>% 
      .[1]
    , fld_dta = read_field_data(study_site_list[1])
    , plt_dta = validation_plots %>% 
      dplyr::filter(study_site == study_site_list[1])
  )
```

```{r}
# what? 
validation_temp %>% dplyr::glimpse()
# output file is the same thing as field_uas_comparison_fn
validation_temp$validation_file_full_path %>% 
  readr::read_csv() %>% 
  dplyr::glimpse()
```

## Full pipeline function

function to map over study sites represented in `ptcld_processing_data`

```{r}
# function to map over study sites represented in ptcld_processing_data
# set up in a way so that only have to read field data from disk once and 
# perform validation for each uas data represented for that site in ptcld_processing_data
# Returns:
# 1) write full validation tree list to disk
# 2) update ptcld_processing_data with metrics for testing:
  # f-score
  # ht rmse
  # dbh rmse
  # path to validation tree list
full_validation_fn = function(study_site_nm) {
  # filter plot data
    validation_plot = validation_plots %>% 
      dplyr::filter(study_site == study_site_nm)
  # read field data
    field_data = read_field_data(study_site_nm)
  # # map over file validation function and return data
    # function for a file name identified by processing_id in ptcld_processing_data
    d = ptcld_processing_data %>% 
      dplyr::filter(study_site == study_site_nm) %>% 
      dplyr::pull(processing_id) %>% 
      purrr::map(validate_file_fn, fld_dta = field_data, plt_dta = validation_plot) %>% 
      dplyr::bind_rows()
  # return
    return(d)
}
```

## Apply validation for all

```{r, results='hide', message=FALSE, warning=FALSE}
ptcld_validation_data = 
  study_site_list %>% 
    purrr::map(full_validation_fn) %>% 
    dplyr::bind_rows()
# write this!
write.csv(
    ptcld_validation_data
    , "../data/ptcld_full_analysis_data.csv"
    , row.names = F
  )
```

what is this validation data?

```{r}
ptcld_validation_data %>% dplyr::glimpse()
# summary of validation metrics
ptcld_validation_data %>% 
  dplyr::select(f_score, tree_height_m_mape, dbh_cm_mape) %>% 
  summary()
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Example Validation Process

Let's go through one example

Data setup using functions defined above

```{r, results='hide', message=FALSE, warning=FALSE}
# read field data
field_data_temp = read_field_data(my_study_site = study_site_list[1])
# read_uas_data
uas_data_temp = read_uas_data(
  my_processing_id = ptcld_processing_data %>% 
    dplyr::filter(study_site==study_site_list[1]) %>% 
    dplyr::pull(processing_id) %>% 
    .[1]
  , my_crs = sf::st_crs(field_data_temp)
)
# true positive
true_positive_trees_temp = true_positive_trees_fn(uas_data = uas_data_temp, field_data = field_data_temp)
# field_uas_comparison_fn
field_uas_comparison_temp = field_uas_comparison_fn(
  uas_data = uas_data_temp
  , field_data = field_data_temp
  , true_positive_trees = true_positive_trees_temp 
  , plot_data = validation_plots %>% dplyr::filter(study_site==study_site_list[1])
)
```

what is this data?

`field_data`

```{r}
# field_data
field_data_temp %>% dplyr::glimpse()
```

`uas_data`

```{r}
# uas_data
uas_data_temp %>% dplyr::glimpse()
```

`true_positive_trees`

```{r}
# true_positive_trees
true_positive_trees_temp %>% dplyr::glimpse()
```

`field_uas_comparison`

```{r}
# field_uas_comparison
field_uas_comparison_temp %>% dplyr::glimpse()
```

### Height vs. DBH of $Tp$, $Co$, $Om$

```{r fld-dta-sum-htdbh}
field_uas_comparison_temp %>% 
  dplyr::mutate(
    dbh_temp = dplyr::coalesce(field_dbh_cm, uas_dbh_cm)
    , ht_temp = dplyr::coalesce(field_tree_height_m, uas_tree_height_m)
  ) %>% 
  ggplot(
    mapping = aes(x = ht_temp, y = dbh_temp, color = field_uas_group)
  ) +
    geom_point(
      mapping = aes(shape = field_uas_group)
      , alpha=0.8
      , size=2
    ) +
    scale_color_viridis_d(option = "cividis", drop = F) +
    scale_x_continuous(breaks = scales::extended_breaks(n=8)) +
    scale_y_continuous(breaks = scales::extended_breaks(n=8)) +
    labs(
      color = "detection"
      , shape = "detection"
      , y = "DBH (cm)"
      , x = "Tree Ht. (m)"
      , title = "UAS and Stem-Mapped Tree Validation Summary"
      , subtitle = "height and DBH relationship"
    ) +
    theme_light() +
    theme(
      legend.position = "top"
      , legend.direction  = "horizontal"
      , legend.title = element_blank()
    ) +
    guides(
      color = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5))
      , shape = guide_legend(reverse = T)
    )  
```

### Height and DBH Distribution $Tp$, $Co$, $Om$

```{r fld-dta-sum-htdbh-dist}
field_uas_comparison_temp %>% 
  dplyr::mutate(
    dbh = dplyr::coalesce(field_dbh_cm, uas_dbh_cm)
    , height = dplyr::coalesce(field_tree_height_m, uas_tree_height_m)
  ) %>% 
  dplyr::select(dbh, height, field_uas_group) %>% 
  tidyr::pivot_longer(cols = -c(field_uas_group), names_to = "metric", values_to = "value") %>% 
  dplyr::group_by(field_uas_group,metric) %>% 
  dplyr::mutate(
    metric = dplyr::case_when(
      metric == "dbh" ~ "DBH (cm)"
      , metric == "height" ~ "Height (m)"
    )
    , n_rows = dplyr::n()
    , plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(n_rows,accuracy=1),")"
    )
  ) %>% 
  ggplot(mapping = aes(x = value, y = plot_lab, fill = field_uas_group)) +
    geom_violin() +
    geom_boxplot(width = 0.1, outlier.shape = NA, color = "gray66") +
    facet_grid(cols = vars(metric), scales = "free_x") +
    scale_fill_viridis_d(option = "cividis", drop = F) +
    scale_x_continuous(breaks = scales::extended_breaks(n=8)) +
    labs(
      fill = ""
      , y = ""
      , x = ""
      , title = "UAS and Stem-Mapped Tree Validation Summary"
      , subtitle = "height and DBH distribution comparison"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
      , strip.text = element_text(color = "black", size = 12)
      , strip.background = element_rect(fill = "gray88")
    )
```

### Detected Overstory ($TP$) Height Difference

Detected overstory tree ($TP$) height reliability.

```{r fld-dta-sum-ht}
field_uas_comparison_temp %>%
  dplyr::filter(field_uas_group == "true positive") %>%
  dplyr::group_by(field_uas_group) %>% 
  dplyr::mutate(
    plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(dplyr::n(),accuracy=1),")"
    )
    , med = median(height_diff_pct, na.rm=T)
    , color_box = med<0
  ) %>% 
  ggplot(mapping = aes(x = height_diff_pct)) + # height_diff_pct
  # ggplot(mapping = aes(x = height_diff_pct, y = plot_lab )) + # height_diff_pct
    geom_vline(xintercept = 0, color = "gray22", lwd = 1) +
    # geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) +
    geom_density(mapping = aes(fill = color_box), alpha = 0.8) +
    geom_vline(aes(xintercept = med), color = "gray66", linetype = "dashed") + # ymin = -Inf, ymax = Inf
    geom_text(
      aes(x = med, y = 0, label = paste0("median: ",scales::percent(med, accuracy = 0.1)))
      , hjust = -0.1, vjust = 1
    ) +
    scale_fill_manual(values = c("steelblue", "coral")) +
    scale_x_continuous(
      labels = scales::percent_format()
      , breaks = scales::extended_breaks(n=8)
      , limits = c(
        -max(field_uas_comparison_temp$abs_height_diff_pct, na.rm = T)
        , max(field_uas_comparison_temp$abs_height_diff_pct, na.rm = T)
      )
    ) +
    scale_y_continuous(NULL, breaks = NULL) +
    labs(
      fill = ""
      , y = ""
      , x = "Percent Difference in Height"
      , title = "Detected Overstory Height Difference"
      , caption = "-values = UAS<field | +values = UAS>field"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
    )
```

### Detected Overstory ($TP$) DBH Difference

Detected overstory tree ($TP$) DBH reliability.

```{r fld-dta-sum-dbh}
field_uas_comparison_temp %>%
  dplyr::filter(field_uas_group == "true positive") %>%
  dplyr::group_by(field_uas_group) %>% 
  dplyr::mutate(
    plot_lab = paste0(
      field_uas_group
      ," (n=", scales::comma(dplyr::n(),accuracy=1),")"
    )
    , med = median(dbh_diff_pct, na.rm=T)
    , color_box = med<0
  ) %>% 
  ggplot(mapping = aes(x = dbh_diff_pct)) + # height_diff_pct
    geom_vline(xintercept = 0, color = "gray22", lwd = 1) +
    geom_density(mapping = aes(fill = color_box), alpha = 0.8) +
    geom_vline(aes(xintercept = med), color = "gray66", linetype = "dashed") + # ymin = -Inf, ymax = Inf
    geom_text(
      aes(x = med, y = 0, label = paste0("median: ",scales::percent(med, accuracy = 0.1)))
      , hjust = -0.1, vjust = 1
    ) +
    scale_fill_manual(values = c("steelblue", "coral")) +
    scale_x_continuous(
      labels = scales::percent_format()
      , breaks = scales::extended_breaks(n=8)
      , limits = c(-2,2)
    ) +
    scale_y_continuous(NULL, breaks = NULL) +
    labs(
      fill = ""
      , y = ""
      , x = "Percent Difference in DBH"
      , title = "Detected Overstory DBH Difference"
      , caption = "-values = UAS<field | +values = UAS>field"
    ) +
    theme_light() +
    theme(
      legend.position = "none"
      , axis.title.x = element_text(size=10, face = "bold")
      , axis.title.y = element_blank()
      , axis.text.y = element_text(color = "black",size=10, face = "bold", hjust = 0)
    )

```

#### Detected Overstory ($TP$) Reliability

```{r fld-dta-sum-rmse, results='asis'}
dbh_f_temp = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(field_dbh_cm)
dbh_u_temp = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(uas_dbh_cm)
ht_f_temp = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(field_tree_height_m)
ht_u_temp = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% dplyr::pull(uas_tree_height_m)

data.frame(
  mae_dbh = Metrics::mae(
    dbh_f_temp
    , dbh_u_temp
  )
  , mape_dbh = Metrics::mape(
    dbh_f_temp
    , dbh_u_temp
  )
  , rmse_dbh = Metrics::rmse(
    dbh_f_temp
    , dbh_u_temp
  )
    ## height
  , mae_height = Metrics::mae(
    ht_f_temp
    , ht_u_temp
  )
  , mape_height = Metrics::mape(
    ht_f_temp
    , ht_u_temp
  )
  , rmse_height = Metrics::rmse(
    ht_f_temp
    , ht_u_temp
  )
) %>% 
  tidyr::pivot_longer(dplyr::everything()) %>% 
  tidyr::separate_wider_delim(cols = name, delim = "_", names = c("error", "metric")) %>% 
  tidyr::pivot_wider(names_from = error, values_from = value) %>% 
  dplyr::mutate(
    metric = dplyr::case_when(
      metric == "dbh" ~ "DBH (cm)"
      , metric == "height" ~ "Height (m)"
    )
    , n = field_uas_comparison_temp %>% dplyr::filter(field_uas_group=="true positive") %>% nrow()
  ) %>% 
    kableExtra::kbl(
      caption = "Detected overstory tree height and DBH prediction performance"
      , col.names = c(
        " "
        , "Mean Abs. Error"
        , "Mean Abs. Percent Error"
        , "Root Mean Squared Error"
        , "N"
      )
      , digits = 2
    ) %>% 
    kableExtra::kable_styling()

```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

